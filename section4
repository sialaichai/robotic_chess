# ==================================================================================
# SECTION 4: VISION & GAME LOOP
# ==================================================================================

def interpolate_grid(tl, tr, br, bl):
    """
    Creates a virtual 8x8 grid based on the 4 corners the user clicked.
    
    How it works:
    1. It creates a "Source" square (the 4 clicks).
    2. It creates a "Destination" square (a perfect 800x800 pixel virtual image).
    3. It calculates a 'Perspective Matrix' (M) that warps the clicked shape into the perfect square.
    4. It then mathematically slices the perfect square into 64 pieces and un-warps them 
       back onto the original camera image to find the exact pixel zone for every chess square (a1-h8).
    """
    dict_sq = {}
    files = "abcdefgh"; ranks = "87654321" 
    
    # The 4 points clicked by the user
    src = np.array([tl, tr, br, bl], dtype="float32")
    # The ideal theoretical square we map them to
    dst = np.array([[0,0], [800,0], [800,800], [0,800]], dtype="float32")
    
    # Calculate the Homography Matrix
    M = cv2.getPerspectiveTransform(dst, src)
    step = 100.0 # 800px / 8 squares = 100px per square
    
    for r_idx, rank in enumerate(ranks):      
        for f_idx, file in enumerate(files): 
            # Define the square in the 'perfect' world
            x1, y1 = f_idx * step, r_idx * step
            pts = np.array([[[x1,y1]], [[x1+step,y1]], [[x1+step,y1+step]], [[x1,y1+step]]], dtype="float32")
            
            # Map it back to the 'distorted' camera world
            cam_pts = cv2.perspectiveTransform(pts, M)
            dict_sq[file + rank] = [[int(c[0][0]), int(c[0][1])] for c in cam_pts]
            
    return dict_sq

def detect_move(frame1, frame2, zones):
    """
    The Core Vision Algorithm: "Image Differencing".
    It compares the 'Before' image (frame1) with the 'Current' image (frame2) 
    to see what changed.
    """
    # 1. BLUR: We slightly blur both images to ignore camera static/noise.
    f1 = cv2.GaussianBlur(frame1, (5,5), 0)
    f2 = cv2.GaussianBlur(frame2, (5,5), 0)
    
    # 2. SUBTRACT: Calculate the absolute difference in color per pixel.
    diff = cv2.absdiff(f1, f2)
    gray = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)
    
    # --- TUNING SETTINGS ---
    # 3. THRESHOLD: Convert gray differences to pure Black/White.
    #    Any pixel difference > 15 becomes White (Changed), others Black (Unchanged).
    #    Lowered to 15 to detect black pieces on dark squares better.
    _, thresh = cv2.threshold(gray, 15, 255, cv2.THRESH_BINARY)
    
    kernel = np.ones((3,3), np.uint8)
    
    # 4. EROSION: Shrinks white blobs slightly to remove tiny noise specks.
    #    Reduced iterations to 1 so we don't accidentally erase the piece we want to see.
    thresh = cv2.erode(thresh, kernel, iterations=1)
    
    # 5. ZONE CHECK: Loop through every square (a1-h8) and count white pixels.
    changed = []
    for sq, poly in zones.items():
        mask = np.zeros(thresh.shape, dtype=np.uint8)
        # Create a mask for just THIS specific square
        cv2.fillPoly(mask, [np.array(poly, dtype=np.int32)], 255)
        # Count how many changed pixels exist inside this square
        score = cv2.countNonZero(cv2.bitwise_and(thresh, thresh, mask=mask))
        
        # 6. SCORE CHECK: If enough pixels changed (>150), mark this square as "Active".
        if score > 150: changed.append((sq, score)) 
        
    # Sort by most changed first (helps if hand shadow touches multiple squares)
    changed.sort(key=lambda x: x[1], reverse=True) 
    return [x[0] for x in changed]

def run_vision_game(robot, is_white, app):
    """
    THE MAIN GAME LOOP.
    Orchestrates the flow: Robot Turn -> Human Turn -> Robot Turn.
    """
    mapper = BoardMapper(is_white_profile=is_white)
    robot_color = "WHITE" if is_white else "BLACK"
    
    # Load the polygon zones generated by the calibration step
    v_file = f"vision_{robot_color.lower()}.json"
    if not os.path.exists(v_file): return print(f"CRITICAL: No vision file {v_file}")
    
    with open(v_file, 'r') as f: v_zones = json.load(f)
    print(f"--- GAME STARTING ({robot_color}) ---")

    # Initialize Engine and Camera
    engine = chess.engine.SimpleEngine.popen_uci(STOCKFISH_PATH)
    cap = cv2.VideoCapture(CAMERA_INDEX, cv2.CAP_DSHOW)
    time.sleep(1)
    board = chess.Board() # Internal Python representation of the chess board

    # --- UNIFIED MOTION CONTROLLER ---
    # We pass the GUI's stop flag so the robot can freeze mid-movement if needed.
    motion = RobotMotion(robot, mapper, lambda: app.stop_requested)
    
    # --- HUD VARIABLES ---
    last_w = "White: --"
    last_b = "Black: --"

    def draw_hud(img):
        """Overlays text onto the video feed."""
        h, w, _ = img.shape
        cv2.putText(img, last_w, (20, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 0), 2)
        cv2.putText(img, last_b, (w - 280, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 255), 2)

    def update_window(duration):
        """Keeps the video window alive while the robot is moving/thinking."""
        end = time.time() + duration
        while time.time() < end:
            ret, frame = cap.read()
            if ret: 
                draw_hud(frame)
                cv2.imshow("Chess Vision", frame)
            cv2.waitKey(30)
    
    # Link the update function to the motion class so it can refresh the video during moves
    motion.safe_wait = update_window

    # Capture the Initial "Empty Board" (or Starting Position) state
    ret, frame_base = cap.read()
    while not ret: update_window(0.5); ret, frame_base = cap.read()

    # --- MAIN LOOP ---
    while not board.is_game_over():
        if app.stop_requested: break
        
        # ==========================
        #       ROBOT TURN
        # ==========================
        if (board.turn == is_white):
            print(f"[{robot_color}] Thinking...")
            result = engine.play(board, chess.engine.Limit(time=0.8)) # Ask Stockfish
            
            san_txt = board.san(result.move) # e.g., "Nf3"
            m_str = result.move.uci()        # e.g., "g1f3"
            sq_src, sq_dst = m_str[0:2], m_str[2:4]
            
            # --- SPECIAL MOVE HANDLING ---
            
            # 1. EN PASSANT (The tricky pawn capture)
            if board.is_en_passant(result.move):
                print(f"[{robot_color}] EN PASSANT!")
                # Calculate where the captured pawn actually sits (behind the destination)
                offset = -8 if board.turn == chess.WHITE else 8
                victim_sq = chess.square_name(result.move.to_square + offset)
                
                # A. Remove Victim to Trash
                trash_x, trash_y = -15.0, 15.0
                vx, vy, _ = mapper.get_coords(victim_sq)
                motion.open_hand()
                motion.smart_move_xyz(vx, vy, 16.0) 
                motion.land_on_square(victim_sq)    
                motion.lock_hand()
                motion.lift_vertical()              
                motion.run_linear_path(motion.last_x, motion.last_y, trash_x, trash_y)
                motion.smart_move_xyz(trash_x, trash_y, 10.0) 
                motion.open_hand()
                motion.smart_move_xyz(trash_x, trash_y, 16.0)
                
                # B. Move Attacker
                motion.execute_move(sq_src, sq_dst)

            # 2. CASTLING (Moving two pieces at once)
            elif board.is_castling(result.move):
                print(f"[{robot_color}] CASTLING ({san_txt})")
                motion.execute_move(sq_src, sq_dst) # Move King
                # Move Rook manually based on King's destination
                if sq_dst == "g1": motion.execute_move("h1", "f1")   
                elif sq_dst == "c1": motion.execute_move("a1", "d1") 
                elif sq_dst == "g8": motion.execute_move("h8", "f8") 
                elif sq_dst == "c8": motion.execute_move("a8", "d8") 
            
            # 3. STANDARD CAPTURE OR MOVE
            elif board.is_capture(result.move):
                motion.execute_capture(sq_src, sq_dst)
            else:
                motion.execute_move(sq_src, sq_dst)

            # 4. PROMOTION (Pawn reaches end)
            if result.move.promotion:
                print(f"[{robot_color}] PROMOTION! Please swap manually.")
                time.sleep(2.0) # Pause to let human swap the Queen in

            if app.stop_requested: break 
            
            # Cleanup
            robot.home()
            board.push(result.move) # Update internal board state
            
            if board.turn == chess.BLACK: last_w = f"White: {san_txt}"
            else: last_b = f"Black: {san_txt}"

            # Update Reference Image:
            # We take a new photo AFTER the robot moves so the computer knows 
            # what the board looks like before the human touches it.
            update_window(2.0) 
            ret, frame_base = cap.read() 
            while not ret: update_window(0.5); ret, frame_base = cap.read()

        # ==========================
        #       HUMAN TURN
        # ==========================
        else:
            print(f"\n[HUMAN] Your Turn...")
            
            user_move = None
            candidate_move = None
            
            # Wait for valid input
            while not user_move:
                if app.stop_requested: break 
                ret, frame = cap.read()
                if not ret: update_window(0.2); continue
                
                # Draw overlays (Grid + Text)
                vis = frame.copy()
                for sq, poly in v_zones.items(): 
                    cv2.polylines(vis, [np.array(poly, np.int32)], True, (0,255,0), 1)
                
                # HUD INSTRUCTIONS
                if candidate_move:
                    lbl = f"Verify: {candidate_move.uci()}? [ENTER=Yes | ESC=No]"
                    cv2.putText(vis, lbl, (20, 100), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 3) 
                else:
                    cv2.putText(vis, "SPACE: Scan | R: Reset Cam", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,255,0), 2)
                
                draw_hud(vis)
                cv2.imshow("Chess Vision", vis)
                key = cv2.waitKey(30)
                
                # --- COMMANDS ---

                # A. RESET CAMERA (Key 'r')
                # Useful if lighting changed or you accidentally bumped the board.
                if key == ord('r'):
                    print("[VISION] Manual Reset Requested...")
                    time.sleep(1.0)
                    ret, frame_base = cap.read() # Re-take "Before" photo
                    print("[VISION] New Reference Image Captured!")
                    candidate_move = None
                    continue 

                # B. CONFIRM / REJECT (Enter/Esc)
                if candidate_move:
                    if key == 13: # ENTER key
                        print(f"[CONFIRMED] Move {candidate_move.uci()} accepted.")
                        user_move = candidate_move
                    elif key == 27: # ESC key
                        print("[CANCELLED] Try again.")
                        candidate_move = None
                    continue

                # C. SCAN (Spacebar)
                if key == 32: 
                    print("[VISION] Scanning...")
                    # Compare current frame vs frame_base
                    changes = detect_move(frame_base, frame, v_zones)
                    
                    # Logic: Find a legal move that matches the changed squares.
                    # e.g., If "e2" and "e4" changed, it's likely "e2e4".
                    match_found = False
                    for m in board.legal_moves:
                        if chess.square_name(m.from_square) in changes and chess.square_name(m.to_square) in changes:
                            candidate_move = m
                            match_found = True
                            print(f"[PROPOSAL] I think you moved: {m.uci()}")
                            break
                    
                    if not match_found:
                        print(f"[VISION] No legal move found. Changes: {changes}")

            if app.stop_requested: break 
            
            # Push human move to board logic
            san_txt = board.san(user_move)
            board.push(user_move)
            
            if board.turn == chess.BLACK: last_w = f"White: {san_txt}"
            else: last_b = f"Black: {san_txt}"

            # Update Reference: The board now looks like this for the robot's next turn.
            frame_base = frame.copy()